<!--blog post: Big O Notation - Python Examples-->
<!--Rachel Curry-->
<!--March 6th, 2025-->

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Blog: Big O Notation</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
<script src="graph.js"></script>
<body>
    <div id="heading" class="heading">
        <h1>Big O Notation — Python Examples</h1>
        <h3>Rachel Curry</h3>
        <h4>March 7th, 2025</h4>
        <p><span class="tag">algorithms</span> <span class="tag">big o notation</span> <span class="tag">minimax</span></p>
    </div>
    <div id="intro-section" class="main-text">
        <p>
            In computer science, <strong>Big O Notation</strong> is a mathematical format to express the computational complexity of
            an algorithm. This allows us to determine the <em>time</em> and <em>space</em> that an algorithm will need as its input changes. 
        </p>
        <p>
            This article will cover how the Big O Notation works, including some examples in Python: a single <code>for</code> loop,
            a nested <code>for</code> loop, and the built-in <code>map</code> iterator. We will also calculate the time complexity of
            the <strong>Minimax Algorithm</strong>, which can be used in many backtracking problems (such as Tic Tac Toe). Within the Minimax-Tic Tac
            Toe analysis, we will mathematically compute how many game states are possible on a 3x3 Tic Tac Toe board.
        </p>
    </div>
    <div id="big-o-explained" class="main-text">
        <h2>Big O Notation</h2>
        <p>
            In Big O Notation, a mathematical function is used to describe the behavior of an algorithm as its input 
            size approaches infinity.
        </p>
        <p class="math">
            f(n) = O(g(n)) as n → ∞
        </p>
        <p>
            Consider the following graph, where <var>n</var> is the size of the input.
        </p>
        <canvas id="bigOGraph" style="width:100%;max-width:600px"></canvas>
        <p>
            If a function does not change the number of operations it performs regardless of input, then the time complexity can 
            be described as <var>O(1)</var>, where the complexity is constant. If the number of operations is directly proportional to the 
            input value <var>n</var>, the time complexity is described as <var>O(n)</var>. 
        </p>
        <p>
            An algorithm's complexity can mathematically be any function, such as <var>f(n) = 6n<sup>2</sup>+4n</var>. However, in common
            practice, Big O Notation is often the <em>upper bound</em> of an algorithm's complexity. This is because as the input size grows,
            the <var>n<sup>2</sup></var> becomes the dominant multiplier, and all other terms will become arbitrary. Therefore, if the 
            time complexity of an algorithm is <var>f(n) = 6n<sup>2</sup>+4n</var>, that can be  simplified to <var>O(n<sup>2</sup>)</var>.
            The same happens with constants that are multiplied to the function. If there is a time complexity <var>O(3n)</var>, that can 
            always be simplified to <var>O(n)</var>.
        </p>
    </div>
    <div id="big-o-examples" class="main-text">
        <h2>Big O Python Examples</h2>
        <h3>Singular <code>for</code> Loop</h3>
        <p>
            Consider the below example. This function, <code>addup</code>, takes in <code>num</code> as its only function parameter. It 
            then includes a singular <code>for</code> loop, which goes around <code>num</code> times and sums the number of times it has looped.
        </p>
        <pre><code>def addup(num):
        sum = 0
        for i in range(num):
            sum +=1
        return sum</code></pre>
        <p>
            The number of times this function will go through the <code>for</code> loop depends solely on what <code>num</code> is. If 
            <code>num</code> is 500,000,000, it will loop that many times. The number of calculations is directly proportional to the 
            input value. Therefore, this function's time complexity is <var>O(n)</var> where <var>n</var> is <code>num</code>.
        </p>
        <h3>Nested <code>for</code> Loop</h3>
        <p>
            Next, we'll look at a <em>nested</em> <code>for</code> loop. The below function <code>shorten</code> takes in an array <code>arr</code> as input. 
            It then loops through the array and prints out each item, and does a secondary nested loop inside the outer one, where it prints out the array 
            starting with the <code>i + 1</code><sup>th</sup> element. 
        </p>
        <pre><code>def shorten(arr):
        for i in range(len(arr)):
            print(arr[i])
            for j in range(i+1, len(arr)):
                print(arr[j])</code></pre>
        <p>
            This function will produce the below output when given <code>arr = [1, 2, 3]</code> as a paramter.
        </p>
        <pre><code>
            1
            2
            3
            2
            3
            3</code></pre>
        <p>
            The first time it went through the loop, it printed out <code>1</code>, and then it went into the secondary loop and printed <code>2</code>
            and <code>3</code>. It went back around and printed <code>2</code> in the outer loop, and then printed <code>3</code> in the inner loop.
            Lastly, it printed <code>3</code> in the outer loop on its final time around, and since there is no index after that, the inner loop didn't
            print anything. 
        </p>
        <p>
            To determine the time complexity of this function, consider what is actually happening inside the loops. Each time it goes through 
            the array and prints out the whole thing, except every following time it ignores the next first element. 
        </p>
        <p>
            If it did not ignore these elements, it would essentially be accessing every element in a <var>n x n</var> matrix and printing them out.
            If that were the case, the time complexity would be <var>O(n<sup>2</sup>)</var>, because it accesses <var>n</var> elements <var>n</var>
            times. But considering it ignores half of the elements in the figurative matrix, the time complexity is technically <var>O(n<sup>2</sup>/2)</var>.
            However, the rule about constants still applies here! The <var>1/2</var> can be removed, because as <var>n</var> approaches infinity, the 
            <var>1/2</var> becomes arbitrary. Therefore, the time complexity of this nested <code>for</code> loop is <var>O(n<sup>2</sup>)</var>.
        </p>
        <h3>Iteration Using <code>map</code></h3>
        <p>
            Python has a built-in function called <code>map</code>. This function iterates over all items in a collection (such as an array) and performs
            an action on them which is specified in the parameters by the user. Consider the below function, which utilizes <code>map</code> to capitalize
            all of the <code>string</code> elements of an array <code>arr</code>.
        </p>
        <pre><code>def capitalize(arr):
        new_arr = list(map(str.upper, arr))
        return new_arr</code></pre>
        <p>
            When given an input <code>arr = ['hello', 'world']</code>, the resulting array will look like this when printed:
        </p>
        <pre><code>['HELLO', 'WORLD']</code></pre>
        <p>
            The time complexity of this function is directly proportional to the array it takes in. It doesn't matter how long the array is, because the <code>map</code>
            function will have to go through every single one to capitalize it regardless of the length. Therefore, the time complexity of this function is <var>O(n)</var>
            where <var>n</var> is the length of the input array. 
        </p>
        <h3>Iteration and Filtering Using <code>map</code> and <code>filter</code></h3>
        <p>
            Python has another built-in function called <code>filter</code>. The <code>map</code> and <code>filter</code> functions are often used together
            to perform actions on data in various collections. The below function <code>double_filter</code> takes in an array <code>arr</code> as a parameter.
            It then goes through every item in the array and doubles it using the <code>map</code> function. Next, it filters the array with <code>filter</code>
            and only keeps the elements that are greater than or equal to 10. 
        </p>
        <pre><code>def double_filter(arr):
        double_arr = list(map(lambda n:n*2, arr))
        filt_arr = list(filter(lambda n:n>=10, double_arr))
        return filt_arr</code></pre>
        <p>
            If you were to input <code>arr = [2, 3, 4, 5, 6, 7]</code> to <code>double_filter</code> and print out the resulting array, <code>filt_arr</code>,
            this would be the output:
        </p>
        <pre><code>[10, 12, 14]</code></pre>
        <p>
            To compute the time complexity, we consider all of the operations that happen in this function:
        </p>
        <ul>
            <li>Doubling the array using <code>map</code></li>
            <li>Filtering the array using <code>filter</code></li>
        </ul>
        <p>
            The <code>map</code> function is <var>O(n)</var> because it goes through each item in the array once, where <var>n</var>
            is the length of the array (the same as was shown in the previous example). The <code>lambda</code> function — which is technically a function of its own
            inside of the <code>map</code> function — is <var>O(1)</var>, because each time it is called, it performs exactly one operation (doubling the item that's passed into it).
            Since <var>O(n) > O(1)</var>, we keep the worst case, or <em>upper bound</em>, as was specified previously, which is <var>O(n)</var> where <var>n</var> is the size
            of the input array <code>arr</code>.
        </p>
        <p>
            The same is true for the <code>filter</code> function. It also has a <code>lambda</code> function inside of it, which is <var>O(1)</var> because every time it is called, it 
            checks if the item passed into it is greater than or equal to 10 only one time. The <code>filter</code> function is <var>O(n)</var>, because it will perform one operation
            for each element of the array that's passed into it, so <var>n</var> is the size of the array <code>arr</code>.
        </p>
        <p>
            So now, we have two operations that are both <var>O(n)</var>. It is as simple as it sounds — we just need to add them together. The <code>double_filter</code> function's time
            complexity is <var>O(2n)</var>. However, the same rule applies for the constant here: we can remove the 2, since it will become arbitrary as <var>n</var> grows. Therefore,
            the <code>double_filter</code> function's time complexity is <var>O(n)</var> where <var>n</var> is the size of the input array <code>arr</code>.
        </p>
    </div>
    <div id="minimax-section" class="main-text">
        <h2>Minimax Algorithm</h2>
        <p>The Minimax Algorithm is an algorithm commonly used in game logic, backtracking, and decision making programs. This algorithm uses the tree structure to "see" all possible
            outcomes of a situation and make the optimal choice based on the depth of the scenario in the tree. 
        </p>
        <p>
            For example, consider the game of Tic Tac Toe. On a 3x3 board, how many possible game states are there? To discover this, first let's define what a game state is more
            specifically. In this context, a <strong>game state</strong> refers to one possible game scenario. This includes all possible situations where the game is either finished or unfinished. 
            For example, below are three different game states:
        </p>
    </div>
    <div id="conclusion" class="main-text">
        <h2>Conclusion (change this word ew)</h2>
        <p>bleh</p>
        <p class="signature">Rachel Curry</p>
    </div>
</body>
</html>